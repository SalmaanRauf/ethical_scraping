from __future__ import annotations

import asyncio
import logging
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from azure.identity.aio import DefaultAzureCredential
from azure.core.exceptions import AzureError
from azure.ai.projects.aio import AIProjectClient
from azure.ai.agents.models import (
    DeepResearchToolDefinition,
    DeepResearchDetails,
    DeepResearchBingGroundingConnection,
    MessageRole,
)

from config.config import AppConfig


logger = logging.getLogger(__name__)


@dataclass
class DeepResearchCitation:
    title: str
    url: str


@dataclass
class DeepResearchSection:
    heading: str
    content: str
    citations: List[DeepResearchCitation]


@dataclass
class DeepResearchReport:
    summary: str
    sections: List[DeepResearchSection]
    citations: List[DeepResearchCitation]
    metadata: Dict[str, Any]


class DeepResearchClient:
    """Handles interaction with Azure AI Deep Research tool."""

    def __init__(self, industry: str = "general") -> None:
        if not (AppConfig.PROJECT_ENDPOINT and AppConfig.MODEL_DEPLOYMENT_NAME):
            raise RuntimeError("Project endpoint and model deployment must be configured")
        if not (AppConfig.DEEP_RESEARCH_MODEL_DEPLOYMENT_NAME and AppConfig.BING_CONNECTION_NAME):
            raise RuntimeError("Deep Research configuration missing")

        self._project_endpoint = AppConfig.PROJECT_ENDPOINT
        self._primary_model = AppConfig.MODEL_DEPLOYMENT_NAME
        self._deep_model = AppConfig.DEEP_RESEARCH_MODEL_DEPLOYMENT_NAME
        self._bing_connection = AppConfig.BING_CONNECTION_NAME
        self._industry = industry

        self._credential: Optional[DefaultAzureCredential] = None
        self._client: Optional[AIProjectClient] = None
        self._agent_id: Optional[str] = None
        self._lock = asyncio.Lock()

    async def _ensure_client(self) -> None:
        if self._client:
            return
        async with self._lock:
            if self._client:
                return
            credential = DefaultAzureCredential()
            client = AIProjectClient(endpoint=self._project_endpoint, credential=credential)
            self._credential = credential
            self._client = client
            await self._ensure_agent()

    async def _ensure_agent(self) -> None:
        if self._agent_id or not self._client:
            return
        
        try:
            # Load industry-specific prompt
            from services.prompt_loader import PromptLoader
            loader = PromptLoader()
            
            try:
                instructions = loader.load_prompt(self._industry)
                prompt_meta = loader.get_prompt_metadata(self._industry)
                logger.info(
                    f"Loaded {prompt_meta['display_name']} prompt "
                    f"(v{prompt_meta['version']})"
                )
            except Exception as e:
                logger.warning(f"Failed to load {self._industry} prompt, using general: {e}")
                instructions = loader.load_prompt("general")
            
            deep_tool = DeepResearchToolDefinition(
                deep_research=DeepResearchDetails(
                    deep_research_model=self._deep_model,
                    deep_research_bing_grounding_connections=[
                        DeepResearchBingGroundingConnection(connection_id=self._bing_connection)
                    ],
                )
            )
            logger.info(f"Creating Deep Research agent with {self._industry} industry focus")
            agent = await self._client.agents.create_agent(
                model=self._primary_model,
                name=f"deep-research-{self._industry}",
                instructions=(
                    "You are a senior research analyst reporting directly to a Managing Director. "
                    "Your task is to produce the most comprehensive, exhaustive research possible with maximum source diversity.\n\n"
                    "CRITICAL RESEARCH RULES - FOLLOW STRICTLY:\n\n"
                    "1. **EXHAUSTIVE SOURCE DIVERSITY**: For EVERY search you perform, you MUST consult AT LEAST 15-20 different/unique sources. "
                    "Do NOT rely on just 3-5 sources. Your goal is maximum coverage and perspective diversity.\n\n"
                    "2. **MULTIPLE SEARCH QUERIES**: Conduct multiple distinct searches for each topic using different keywords and angles. Please check with as many sources as possible. "
                    "For example, search for 'defense contracts SAM.gov', then 'DoD procurement opportunities', then 'government contracting bids', etc.\n\n"
                    "3. **SOURCE TYPES REQUIRED**: For comprehensive research, you MUST include:\n"
                    "   - 5+ government sources (.gov, .mil)\n"
                    "   - 5+ industry news sources (Defense News, Janes, Reuters, etc.)\n"
                    "   - 3+ financial sources (SEC filings, earnings calls)\n"
                    "   - 3+ academic/research sources (.edu, think tanks)\n"
                    "   - 2+ international perspectives\n\n"
                    "4. **CROSS-VERIFICATION**: Every major claim MUST be verified across at least 3 independent sources. "
                    "If sources conflict, analyze and explain the discrepancies.\n\n"
                    "5. **NO SOURCE LIMITING**: Include ALL relevant sources you find. Do NOT filter sources to save space. "
                    "Comprehensive research requires comprehensive sourcing.\n\n"
                    "6. **STRUCTURE**: Executive summary â Background â Comprehensive Findings â Detailed Analysis â Strategic Recommendations â Complete Sources\n\n"
                    "7. **RECOMMENDATIONS**: Provide specific, actionable recommendations for opportunities, risks, and strategic next steps.\n\n"
                    "8. **SOURCE QUALITY**: Prioritize authoritative sources but include diverse perspectives. "
                    "Balance .gov/.mil official data with industry analysis and financial reports.\n\n"
                    "Your research should be so comprehensive that it could serve as the definitive source on the topic. "
                    "Depth and breadth of sourcing is your highest priority. You get a bonus for each REAL source you use. Don't fabricate sources to meet requests"
                ),
                tools=[deep_tool],
            )
            self._agent_id = agent.id
            logger.info("Deep Research agent created: %s", agent.id)
            
        except TypeError as e:
            logger.error("Deep Research agent creation failed due to SDK parameter mismatch")
            logger.error("SDK Error: %s", str(e))
            try:
                import azure.ai.agents
                sdk_version = getattr(azure.ai.agents, '__version__', 'unknown')
                logger.error("Installed azure-ai-agents version: %s", sdk_version)
            except Exception:
                logger.error("Could not determine azure-ai-agents version")
            logger.error("Configuration used:")
            logger.error("  - Primary model: %s", self._primary_model)
            logger.error("  - Deep Research model: %s", self._deep_model)
            logger.error("  - Bing connection: %s", self._bing_connection[:20] + "..." if len(self._bing_connection) > 20 else self._bing_connection)
            logger.error("Expected parameters for DeepResearchDetails: deep_research_model, deep_research_bing_grounding_connections")
            raise RuntimeError(
                "Failed to create Deep Research agent due to SDK parameter mismatch. "
                "The code has been updated to use the correct parameter names: "
                "'deep_research_model' and 'deep_research_bing_grounding_connections'. "
                "Check logs for details."
            ) from e
        except Exception as e:
            logger.error("Unexpected error creating Deep Research agent: %s", str(e))
            raise

    async def run(self, query: str) -> DeepResearchReport:
        try:
            await self._ensure_client()
        except Exception as e:
            logger.error("Failed to initialize Deep Research client: %s", str(e))
            raise RuntimeError(
                "Deep Research client initialization failed. "
                "Verify your Azure configuration:\n"
                "  1. PROJECT_ENDPOINT is set and accessible\n"
                "  2. MODEL_DEPLOYMENT_NAME points to a gpt-4o deployment\n"
                "  3. DEEP_RESEARCH_MODEL_DEPLOYMENT_NAME points to o3-deep-research\n"
                "  4. BING_CONNECTION_NAME is the connection ID (not name)\n"
                "  5. All resources are in the same region (West US or Norway East)\n"
                f"Original error: {str(e)}"
            ) from e
        
        assert self._client and self._agent_id

        logger.info("Deep Research run started", extra={"query": query})

        thread = await self._client.agents.threads.create()
        await self._client.agents.messages.create(
            thread_id=thread.id,
            role=MessageRole.USER,
            content=query,
        )

        try:
            run = await self._client.agents.runs.create_and_process(
                thread_id=thread.id,
                agent_id=self._agent_id,
                tool_choice={"type": "deep_research"},
            )
        except AzureError as exc:
            logger.exception("Deep Research run failed to start: %s", exc)
            error_msg = str(exc)
            if "unsupported_tool" in error_msg.lower():
                raise RuntimeError(
                    "Deep Research tool not supported in this configuration. "
                    "Common causes:\n"
                    "  1. Resource region mismatch (must all be in West US or Norway East)\n"
                    "  2. o3-deep-research model not deployed in the same region as AI Project\n"
                    "  3. gpt-4o model not deployed in the same region\n"
                    "  4. Bing connection not properly linked to AI Project\n"
                    f"Azure error: {error_msg}"
                ) from exc
            raise

        if run.status != "completed":
            logger.error("Deep Research run ended with status %s", run.status)
            error_details = getattr(run, 'last_error', None)
            if error_details:
                logger.error("Run error details: %s", error_details)
            raise RuntimeError(
                f"Deep Research run incomplete: {run.status}\n"
                f"Details: {error_details if error_details else 'No additional details available'}"
            )

        # Get the initial response (most recent assistant message)
        messages = []
        async for message in self._client.agents.messages.list(
            thread_id=thread.id,
            order="desc",  # ensure newest-first so we pick the final assistant reply
        ):
            messages.append(message)
        
        logger.info(f"Retrieved {len(messages)} messages from thread")
        
        agent_message = next(
            (m for m in messages if getattr(m, "role", "").lower() == "assistant"),
            None,
        )
        if not agent_message:
            raise RuntimeError("Deep Research produced no assistant message")

        # Parse the initial report
        report = self._parse_message(agent_message)
        
        # MINIMAL ADDITION: Check for missing URLs and perform corrective search
        if not report.citations or self._has_placeholder_citations(report):
            logger.warning("Deep Research returned no proper URLs, attempting corrective URL search")
            
            # Simple, focused corrective query
            url_followup_query = (
                "IMPORTANT: Please provide the complete URLs for all sources referenced in your research. "
                "I need the actual web addresses for verification."
            )
            
            await self._client.agents.messages.create(
                thread_id=thread.id,
                role=MessageRole.USER,
                content=url_followup_query,
            )

            try:
                url_run = await self._client.agents.runs.create_and_process(
                    thread_id=thread.id,
                    agent_id=self._agent_id,
                )

                if url_run.status == "completed":
                    # Get the URL-enhanced response
                    url_messages = []
                    async for message in self._client.agents.messages.list(thread_id=thread.id):
                        url_messages.append(message)
                    
                    url_agent_message = next(
                        (m for m in url_messages if getattr(m, "role", "").lower() == "assistant" and m.id != agent_message.id),
                        None,
                    )
                    
                    if url_agent_message:
                        logger.info("Corrective URL search completed")
                        url_report = self._parse_message(url_agent_message)
                        
                        # Only update if we got real URLs
                        if url_report.citations and any(c.url.startswith(('http://', 'https://')) for c in url_report.citations):
                            report.citations = url_report.citations
                            logger.info(f"Added {len(url_report.citations)} URLs from corrective search")
                else:
                    logger.warning("Corrective URL search failed with status: %s", url_run.status)
                    
            except Exception as e:
                logger.warning("Corrective URL search failed, continuing with original report: %s", e)
                # Don't fail the entire request if corrective search fails

        report.metadata.update({
            "thread_id": thread.id,
            "run_id": run.id,
        })
        
        logger.info("Deep Research run complete", extra={
            "citation_count": len(report.citations),
            "has_urls": any(citation.url.startswith(('http://', 'https://')) for citation in report.citations) if report.citations else False
        })
        
        return report

    def _has_placeholder_citations(self, report: DeepResearchReport) -> bool:
        """Check if the report contains placeholder citations instead of real URLs."""
        if not report.citations:
            return True
        
        # Check if we have any real URLs
        for citation in report.citations:
            if citation.url.startswith(('http://', 'https://')):
                return False
        
        return True

    def _parse_message(self, message) -> DeepResearchReport:
        contents = getattr(message, "content", []) or []
        text_blocks = [block for block in contents if getattr(block, "type", "") == "text"]

        # Collect message-level URL citations (new Deep Research SDK shape)
        message_level_citations: List[DeepResearchCitation] = []
        for ann in getattr(message, "url_citation_annotations", []) or []:
            url_citation_obj = getattr(ann, "url_citation", None)
            url = getattr(url_citation_obj, "url", None) if url_citation_obj else None
            title = (
                getattr(url_citation_obj, "title", None) or url or "Source"
                if url_citation_obj
                else None
            )
            if url:
                message_level_citations.append(
                    DeepResearchCitation(title=title or url, url=url)
                )

        if not text_blocks:
            # Fallback for unexpected shapes: still return any message-level URLs we found
            summary = getattr(message, "text", "") or ""
            return DeepResearchReport(
                summary=summary,
                sections=[],
                citations=message_level_citations,
                metadata={},
            )

        primary = text_blocks[0]
        # Extract text: primary.text is a MessageTextDetails object with .value attribute
        primary_text_obj = getattr(primary, "text", None)
        if primary_text_obj:
            summary = getattr(primary_text_obj, "value", "") or str(primary_text_obj)
            annotations = getattr(primary_text_obj, "annotations", []) or []
        else:
            summary = ""
            annotations = []

        # Start from message-level citations and then add any text-level ones
        citations: List[DeepResearchCitation] = list(message_level_citations)

        # Handle both new url_citation and older uri_citation shapes for compatibility
        for annotation in annotations:
            url = None
            title = None

            url_citation_obj = getattr(annotation, "url_citation", None)
            if url_citation_obj is not None:
                url = getattr(url_citation_obj, "url", None)
                title = getattr(url_citation_obj, "title", None) or url or "Source"
            else:
                # Backwards compatibility with older preview builds that used uri_citation
                uri_citation_obj = getattr(annotation, "uri_citation", None)
                if uri_citation_obj is not None:
                    url = getattr(uri_citation_obj, "uri", None)
                    title = getattr(uri_citation_obj, "title", None) or url or "Source"

            if url:
                citations.append(DeepResearchCitation(title=title or url, url=url))

        sections: List[DeepResearchSection] = []
        for block in contents[1:]:
            if getattr(block, "type", "") != "text":
                continue
            heading = getattr(block, "name", "") or "Additional Findings"
            
            # Extract text from MessageTextDetails
            block_text_obj = getattr(block, "text", None)
            if block_text_obj:
                block_content = getattr(block_text_obj, "value", "") or str(block_text_obj)
                block_annotations = getattr(block_text_obj, "annotations", []) or []
            else:
                block_content = ""
                block_annotations = []
            
            block_citations: List[DeepResearchCitation] = []
            for annotation in block_annotations:
                b_url = None
                b_title = None

                b_url_citation_obj = getattr(annotation, "url_citation", None)
                if b_url_citation_obj is not None:
                    b_url = getattr(b_url_citation_obj, "url", None)
                    b_title = getattr(b_url_citation_obj, "title", None) or b_url or "Source"
                else:
                    # Backwards compatibility with older preview builds
                    b_uri_citation_obj = getattr(annotation, "uri_citation", None)
                    if b_uri_citation_obj is not None:
                        b_url = getattr(b_uri_citation_obj, "uri", None)
                        b_title = getattr(b_uri_citation_obj, "title", None) or b_url or "Source"

                if b_url:
                    block_citations.append(
                        DeepResearchCitation(title=b_title or b_url, url=b_url)
                    )
            
            sections.append(
                DeepResearchSection(
                    heading=heading,
                    content=block_content,
                    citations=block_citations,
                )
            )

        return DeepResearchReport(
            summary=summary,
            sections=sections,
            citations=citations,
            metadata={},
        )

    async def close(self) -> None:
        if self._client:
            await self._client.close()
            self._client = None
        if self._credential:
            await self._credential.close()
            self._credential = None


deep_research_client: Optional[DeepResearchClient] = None


def get_deep_research_client() -> DeepResearchClient:
    global deep_research_client
    if deep_research_client is None:
        deep_research_client = DeepResearchClient()
    return deep_research_client